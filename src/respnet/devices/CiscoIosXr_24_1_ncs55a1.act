import json
import xml
import yang.adata
import yang.gdata

# == This file is generated ==


mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vrf_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast()
        return None


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()
        return None


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()
        return None


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast
    multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast
    flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast=None, flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        self.unicast = unicast
        self_unicast = self.unicast
        if self_unicast is not None:
            self_unicast._parent = self
        self.multicast = multicast
        self_multicast = self.multicast
        if self_multicast is not None:
            self_multicast._parent = self
        self.flowspec = flowspec
        self_flowspec = self.flowspec
        if self_flowspec is not None:
            self_flowspec._parent = self

    mut def create_unicast(self):
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast()
        self.unicast = res
        return res

    mut def create_multicast(self):
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast()
        self.multicast = res
        return res

    mut def create_flowspec(self):
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec()
        self.flowspec = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _unicast = self.unicast
        _multicast = self.multicast
        _flowspec = self.flowspec
        if _unicast is not None:
            children['unicast'] = _unicast.to_gdata()
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        if _flowspec is not None:
            children['flowspec'] = _flowspec.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.from_gdata(n.get_opt_container("unicast")), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.from_gdata(n.get_opt_container("multicast")), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.from_gdata(n.get_opt_container("flowspec")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast.from_xml(yang.gdata.get_xml_opt_child(n, "unicast")), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast.from_xml(yang.gdata.get_xml_opt_child(n, "multicast")), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec.from_xml(yang.gdata.get_xml_opt_child(n, "flowspec")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-vrf-cfg:unicast' or point == 'unicast':
            child = {'unicast': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-vrf-cfg:multicast' or point == 'multicast':
            child = {'multicast': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-vrf-cfg:flowspec' or point == 'flowspec':
            child = {'flowspec': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_unicast_full = jd.get('um-vrf-cfg:unicast')
    child_unicast = child_unicast_full if child_unicast_full is not None else jd.get('unicast')
    if child_unicast is not None and isinstance(child_unicast, dict):
        children['unicast'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(child_unicast)
    child_multicast_full = jd.get('um-vrf-cfg:multicast')
    child_multicast = child_multicast_full if child_multicast_full is not None else jd.get('multicast')
    if child_multicast is not None and isinstance(child_multicast, dict):
        children['multicast'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(child_multicast)
    child_flowspec_full = jd.get('um-vrf-cfg:flowspec')
    child_flowspec = child_flowspec_full if child_flowspec_full is not None else jd.get('flowspec')
    if child_flowspec is not None and isinstance(child_flowspec, dict):
        children['flowspec'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(child_flowspec)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_unicast = n.children.get('unicast')
    if child_unicast is not None:
        if isinstance(child_unicast, yang.gdata.Container):
            children['unicast'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__unicast(child_unicast)
    child_multicast = n.children.get('multicast')
    if child_multicast is not None:
        if isinstance(child_multicast, yang.gdata.Container):
            children['multicast'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__multicast(child_multicast)
    child_flowspec = n.children.get('flowspec')
    if child_flowspec is not None:
        if isinstance(child_flowspec, yang.gdata.Container):
            children['flowspec'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4__flowspec(child_flowspec)
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast()
        return None


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()
        return None


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()
        return None


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(yang.adata.MNode):
    unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast
    multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast
    flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec

    mut def __init__(self, unicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast=None, multicast: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast=None, flowspec: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        self.unicast = unicast
        self_unicast = self.unicast
        if self_unicast is not None:
            self_unicast._parent = self
        self.multicast = multicast
        self_multicast = self.multicast
        if self_multicast is not None:
            self_multicast._parent = self
        self.flowspec = flowspec
        self_flowspec = self.flowspec
        if self_flowspec is not None:
            self_flowspec._parent = self

    mut def create_unicast(self):
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast()
        self.unicast = res
        return res

    mut def create_multicast(self):
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast()
        self.multicast = res
        return res

    mut def create_flowspec(self):
        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec()
        self.flowspec = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _unicast = self.unicast
        _multicast = self.multicast
        _flowspec = self.flowspec
        if _unicast is not None:
            children['unicast'] = _unicast.to_gdata()
        if _multicast is not None:
            children['multicast'] = _multicast.to_gdata()
        if _flowspec is not None:
            children['flowspec'] = _flowspec.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.from_gdata(n.get_opt_container("unicast")), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.from_gdata(n.get_opt_container("multicast")), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.from_gdata(n.get_opt_container("flowspec")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(unicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast.from_xml(yang.gdata.get_xml_opt_child(n, "unicast")), multicast=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast.from_xml(yang.gdata.get_xml_opt_child(n, "multicast")), flowspec=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec.from_xml(yang.gdata.get_xml_opt_child(n, "flowspec")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-vrf-cfg:unicast' or point == 'unicast':
            child = {'unicast': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-vrf-cfg:multicast' or point == 'multicast':
            child = {'multicast': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-vrf-cfg:flowspec' or point == 'flowspec':
            child = {'flowspec': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_unicast_full = jd.get('um-vrf-cfg:unicast')
    child_unicast = child_unicast_full if child_unicast_full is not None else jd.get('unicast')
    if child_unicast is not None and isinstance(child_unicast, dict):
        children['unicast'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(child_unicast)
    child_multicast_full = jd.get('um-vrf-cfg:multicast')
    child_multicast = child_multicast_full if child_multicast_full is not None else jd.get('multicast')
    if child_multicast is not None and isinstance(child_multicast, dict):
        children['multicast'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(child_multicast)
    child_flowspec_full = jd.get('um-vrf-cfg:flowspec')
    child_flowspec = child_flowspec_full if child_flowspec_full is not None else jd.get('flowspec')
    if child_flowspec is not None and isinstance(child_flowspec, dict):
        children['flowspec'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(child_flowspec)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_unicast = n.children.get('unicast')
    if child_unicast is not None:
        if isinstance(child_unicast, yang.gdata.Container):
            children['unicast'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__unicast(child_unicast)
    child_multicast = n.children.get('multicast')
    if child_multicast is not None:
        if isinstance(child_multicast, yang.gdata.Container):
            children['multicast'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__multicast(child_multicast)
    child_flowspec = n.children.get('flowspec')
    if child_flowspec is not None:
        if isinstance(child_flowspec, yang.gdata.Container):
            children['flowspec'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6__flowspec(child_flowspec)
    return children


class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(yang.adata.MNode):
    ipv4: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4
    ipv6: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6

    mut def __init__(self, ipv4: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4=None, ipv6: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        if ipv4 is not None:
            self.ipv4 = ipv4
        else:
            self.ipv4 = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4()
        self_ipv4 = self.ipv4
        if self_ipv4 is not None:
            self_ipv4._parent = self
        if ipv6 is not None:
            self.ipv6 = ipv6
        else:
            self.ipv6 = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6()
        self_ipv6 = self.ipv6
        if self_ipv6 is not None:
            self_ipv6._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ipv4 = self.ipv4
        _ipv6 = self.ipv6
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(ipv4=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4.from_gdata(n.get_opt_container("ipv4")), ipv6=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6.from_gdata(n.get_opt_container("ipv6")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(ipv4=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4.from_xml(yang.gdata.get_xml_opt_child(n, "ipv4")), ipv6=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6.from_xml(yang.gdata.get_xml_opt_child(n, "ipv6")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-vrf-cfg:ipv4' or point == 'ipv4':
            child = {'ipv4': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-vrf-cfg:ipv6' or point == 'ipv6':
            child = {'ipv6': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ipv4_full = jd.get('um-vrf-cfg:ipv4')
    child_ipv4 = child_ipv4_full if child_ipv4_full is not None else jd.get('ipv4')
    if child_ipv4 is not None and isinstance(child_ipv4, dict):
        children['ipv4'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(child_ipv4)
    child_ipv6_full = jd.get('um-vrf-cfg:ipv6')
    child_ipv6 = child_ipv6_full if child_ipv6_full is not None else jd.get('ipv6')
    if child_ipv6 is not None and isinstance(child_ipv6, dict):
        children['ipv6'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(child_ipv6)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_ipv4 = n.children.get('ipv4')
    if child_ipv4 is not None:
        if isinstance(child_ipv4, yang.gdata.Container):
            children['ipv4'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv4(child_ipv4)
    child_ipv6 = n.children.get('ipv6')
    if child_ipv6 is not None:
        if isinstance(child_ipv6, yang.gdata.Container):
            children['ipv6'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family__ipv6(child_ipv6)
    return children


mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn__id(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(yang.adata.MNode):
    id: ?str

    mut def __init__(self, id: ?str):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        self.id = id

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _id = self.id
        if _id is not None:
            children['id'] = yang.gdata.Leaf('string', _id)
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(id=n.get_opt_str("id"))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(id=yang.gdata.from_xml_opt_str(n, "id"))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-vrf-cfg:id' or point == 'id':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_id_full = jd.get('um-vrf-cfg:id')
    child_id = child_id_full if child_id_full is not None else jd.get('id')
    if child_id is not None:
        children['id'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn__id(child_id)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_id = n.children.get('id')
    if child_id is not None:
        if isinstance(child_id, yang.gdata.Leaf):
            children['id'] = child_id.val
    return children


mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(yang.adata.MNode):
    vrf_name: str
    address_family: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family
    vpn: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn
    description: ?str

    mut def __init__(self, vrf_name: str, address_family: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family=None, vpn: ?Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn=None, description: ?str):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        self.vrf_name = vrf_name
        if address_family is not None:
            self.address_family = address_family
        else:
            self.address_family = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family()
        self_address_family = self.address_family
        if self_address_family is not None:
            self_address_family._parent = self
        if vpn is not None:
            self.vpn = vpn
        else:
            self.vpn = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn()
        self_vpn = self.vpn
        if self_vpn is not None:
            self_vpn._parent = self
        self.description = description

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf_name = self.vrf_name
        _address_family = self.address_family
        _vpn = self.vpn
        _description = self.description
        if _vrf_name is not None:
            children['vrf-name'] = yang.gdata.Leaf('string', _vrf_name)
        if _address_family is not None:
            children['address-family'] = _address_family.to_gdata()
        if _vpn is not None:
            children['vpn'] = _vpn.to_gdata()
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.vrf_name)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(vrf_name=n.get_str("vrf-name"), address_family=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family.from_gdata(n.get_opt_container("address-family")), vpn=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn.from_gdata(n.get_opt_container("vpn")), description=n.get_opt_str("description"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry:
        return Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(vrf_name=yang.gdata.from_xml_str(n, "vrf-name"), address_family=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family.from_xml(yang.gdata.get_xml_opt_child(n, "address-family")), vpn=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn.from_xml(yang.gdata.get_xml_opt_child(n, "vpn")), description=yang.gdata.from_xml_opt_str(n, "description"))

class Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        self._name = 'vrf'
        self.elements = elements

    mut def create(self, vrf_name):
        for e in self.elements:
            match = True
            if e.vrf_name != vrf_name:
                match = False
                break
            if match:
                return e

        res = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry(vrf_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['vrf-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]:
        res = []
        for node in nodes:
            res.append(Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry.from_xml(node))
        return res


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['vrf-name']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'address-family':
            children['address-family'] = from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(jd, rest_path, op)
        if point == 'vpn':
            children['vpn'] = from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(jd, rest_path, op)
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['vrf-name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['vrf-name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['vrf-name'], [from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_vrf_name_full = jd.get('um-vrf-cfg:vrf-name')
    child_vrf_name = child_vrf_name_full if child_vrf_name_full is not None else jd.get('vrf-name')
    if child_vrf_name is not None:
        children['vrf-name'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vrf_name(child_vrf_name)
    child_address_family_full = jd.get('um-vrf-cfg:address-family')
    child_address_family = child_address_family_full if child_address_family_full is not None else jd.get('address-family')
    if child_address_family is not None and isinstance(child_address_family, dict):
        children['address-family'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(child_address_family)
    child_vpn_full = jd.get('um-vrf-cfg:vpn')
    child_vpn = child_vpn_full if child_vpn_full is not None else jd.get('vpn')
    if child_vpn is not None and isinstance(child_vpn, dict):
        children['vpn'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(child_vpn)
    child_description_full = jd.get('um-vrf-cfg:description')
    child_description = child_description_full if child_description_full is not None else jd.get('description')
    if child_description is not None:
        children['description'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__description(child_description)
    return yang.gdata.ListElement([str(child_vrf_name if child_vrf_name is not None else "")], children)

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(e))
    return yang.gdata.List(keys=['vrf-name'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_vrf_name = n.children.get('vrf-name')
    if child_vrf_name is not None:
        if isinstance(child_vrf_name, yang.gdata.Leaf):
            children['vrf-name'] = child_vrf_name.val
    child_address_family = n.children.get('address-family')
    if child_address_family is not None:
        if isinstance(child_address_family, yang.gdata.Container):
            children['address-family'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__address_family(child_address_family)
    child_vpn = n.children.get('vpn')
    if child_vpn is not None:
        if isinstance(child_vpn, yang.gdata.Container):
            children['vpn'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf__vpn(child_vpn)
    child_description = n.children.get('description')
    if child_description is not None:
        if isinstance(child_description, yang.gdata.Leaf):
            children['description'] = child_description.val
    return children

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_element(e))
    return elements


class Cisco_IOS_XR_um_vrf_cfg__vrfs(yang.adata.MNode):
    vrf: Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf

    mut def __init__(self, vrf: list[Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf_entry]=[]):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg"
        self.vrf = Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(elements=vrf)
        self.vrf._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrf = self.vrf
        if _vrf is not None:
            children['vrf'] = _vrf.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs(vrf=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf.from_gdata(n.get_opt_list("vrf")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_vrf_cfg__vrfs:
        if n != None:
            return Cisco_IOS_XR_um_vrf_cfg__vrfs(vrf=Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf.from_xml(yang.gdata.get_xml_children(n, "vrf")))
        return Cisco_IOS_XR_um_vrf_cfg__vrfs()


mut def from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-vrf-cfg:vrf' or point == 'vrf':
            child = {'vrf': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_vrf_full = jd.get('um-vrf-cfg:vrf')
    child_vrf = child_vrf_full if child_vrf_full is not None else jd.get('vrf')
    if child_vrf is not None and isinstance(child_vrf, list):
        children['vrf'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(child_vrf)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_vrf = n.children.get('vrf')
    if child_vrf is not None:
        if isinstance(child_vrf, yang.gdata.List):
            children['vrf'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs__vrf(child_vrf)
    return children


mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__interface_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(yang.adata.MNode):
    l2transport: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport
    point_to_point: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point
    multipoint: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint

    mut def __init__(self, l2transport: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport=None, point_to_point: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point=None, multipoint: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        self.l2transport = l2transport
        self_l2transport = self.l2transport
        if self_l2transport is not None:
            self_l2transport._parent = self
        self.point_to_point = point_to_point
        self_point_to_point = self.point_to_point
        if self_point_to_point is not None:
            self_point_to_point._parent = self
        self.multipoint = multipoint
        self_multipoint = self.multipoint
        if self_multipoint is not None:
            self_multipoint._parent = self

    mut def create_l2transport(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport()
        self.l2transport = res
        return res

    mut def create_point_to_point(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point()
        self.point_to_point = res
        return res

    mut def create_multipoint(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint()
        self.multipoint = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _l2transport = self.l2transport
        _point_to_point = self.point_to_point
        _multipoint = self.multipoint
        if _l2transport is not None:
            children['l2transport'] = _l2transport.to_gdata()
        if _point_to_point is not None:
            children['point-to-point'] = _point_to_point.to_gdata()
        if _multipoint is not None:
            children['multipoint'] = _multipoint.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(l2transport=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.from_gdata(n.get_opt_container("l2transport")), point_to_point=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.from_gdata(n.get_opt_container("point-to-point")), multipoint=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.from_gdata(n.get_opt_container("multipoint")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(l2transport=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport.from_xml(yang.gdata.get_xml_opt_child(n, "l2transport")), point_to_point=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point.from_xml(yang.gdata.get_xml_opt_child(n, "point-to-point")), multipoint=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint.from_xml(yang.gdata.get_xml_opt_child(n, "multipoint")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-interface-cfg:l2transport' or point == 'l2transport':
            child = {'l2transport': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-interface-cfg:point-to-point' or point == 'point-to-point':
            child = {'point-to-point': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-interface-cfg:multipoint' or point == 'multipoint':
            child = {'multipoint': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_l2transport_full = jd.get('um-interface-cfg:l2transport')
    child_l2transport = child_l2transport_full if child_l2transport_full is not None else jd.get('l2transport')
    if child_l2transport is not None and isinstance(child_l2transport, dict):
        children['l2transport'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(child_l2transport)
    child_point_to_point_full = jd.get('um-interface-cfg:point-to-point')
    child_point_to_point = child_point_to_point_full if child_point_to_point_full is not None else jd.get('point-to-point')
    if child_point_to_point is not None and isinstance(child_point_to_point, dict):
        children['point-to-point'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(child_point_to_point)
    child_multipoint_full = jd.get('um-interface-cfg:multipoint')
    child_multipoint = child_multipoint_full if child_multipoint_full is not None else jd.get('multipoint')
    if child_multipoint is not None and isinstance(child_multipoint, dict):
        children['multipoint'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(child_multipoint)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_l2transport = n.children.get('l2transport')
    if child_l2transport is not None:
        if isinstance(child_l2transport, yang.gdata.Container):
            children['l2transport'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__l2transport(child_l2transport)
    child_point_to_point = n.children.get('point-to-point')
    if child_point_to_point is not None:
        if isinstance(child_point_to_point, yang.gdata.Container):
            children['point-to-point'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__point_to_point(child_point_to_point)
    child_multipoint = n.children.get('multipoint')
    if child_multipoint is not None:
        if isinstance(child_multipoint, yang.gdata.Container):
            children['multipoint'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type__multipoint(child_multipoint)
    return children


mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__netmask(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__route_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(yang.adata.MNode):
    address: str
    netmask: str
    route_tag: ?int
    algorithm: ?int

    mut def __init__(self, address: str, netmask: str, route_tag: ?int, algorithm: ?int):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg"
        self.address = address
        self.netmask = netmask
        self.route_tag = route_tag
        self.algorithm = algorithm

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        _netmask = self.netmask
        _route_tag = self.route_tag
        _algorithm = self.algorithm
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        if _netmask is not None:
            children['netmask'] = yang.gdata.Leaf('string', _netmask)
        if _route_tag is not None:
            children['route-tag'] = yang.gdata.Leaf('uint32', _route_tag)
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('uint32', _algorithm)
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(address=n.get_str("address"), netmask=n.get_str("netmask"), route_tag=n.get_opt_int("route-tag"), algorithm=n.get_opt_int("algorithm"))
        raise ValueError("Missing required subtree Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address")

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(address=yang.gdata.from_xml_str(n, "address"), netmask=yang.gdata.from_xml_str(n, "netmask"), route_tag=yang.gdata.from_xml_opt_int(n, "route-tag"), algorithm=yang.gdata.from_xml_opt_int(n, "algorithm"))
        raise ValueError("Missing required subtree Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address")


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-if-ip-address-cfg:address' or point == 'address':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'um-if-ip-address-cfg:netmask' or point == 'netmask':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'um-if-ip-address-cfg:route-tag' or point == 'route-tag':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'um-if-ip-address-cfg:algorithm' or point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_full = jd.get('um-if-ip-address-cfg:address')
    child_address = child_address_full if child_address_full is not None else jd.get('address')
    if child_address is not None:
        children['address'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__address(child_address)
    child_netmask_full = jd.get('um-if-ip-address-cfg:netmask')
    child_netmask = child_netmask_full if child_netmask_full is not None else jd.get('netmask')
    if child_netmask is not None:
        children['netmask'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__netmask(child_netmask)
    child_route_tag_full = jd.get('um-if-ip-address-cfg:route-tag')
    child_route_tag = child_route_tag_full if child_route_tag_full is not None else jd.get('route-tag')
    if child_route_tag is not None:
        children['route-tag'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__route_tag(child_route_tag)
    child_algorithm_full = jd.get('um-if-ip-address-cfg:algorithm')
    child_algorithm = child_algorithm_full if child_algorithm_full is not None else jd.get('algorithm')
    if child_algorithm is not None:
        children['algorithm'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address__algorithm(child_algorithm)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address = n.children.get('address')
    if child_address is not None:
        if isinstance(child_address, yang.gdata.Leaf):
            children['address'] = child_address.val
    child_netmask = n.children.get('netmask')
    if child_netmask is not None:
        if isinstance(child_netmask, yang.gdata.Leaf):
            children['netmask'] = child_netmask.val
    child_route_tag = n.children.get('route-tag')
    if child_route_tag is not None:
        if isinstance(child_route_tag, yang.gdata.Leaf):
            children['route-tag'] = child_route_tag.val
    child_algorithm = n.children.get('algorithm')
    if child_algorithm is not None:
        if isinstance(child_algorithm, yang.gdata.Leaf):
            children['algorithm'] = child_algorithm.val
    return children


mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__address(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__netmask(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__route_tag(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__algorithm(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(yang.adata.MNode):
    address: str
    netmask: str
    route_tag: ?int
    algorithm: ?int

    mut def __init__(self, address: str, netmask: str, route_tag: ?int, algorithm: ?int):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg"
        self.address = address
        self.netmask = netmask
        self.route_tag = route_tag
        self.algorithm = algorithm

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        _netmask = self.netmask
        _route_tag = self.route_tag
        _algorithm = self.algorithm
        if _address is not None:
            children['address'] = yang.gdata.Leaf('string', _address)
        if _netmask is not None:
            children['netmask'] = yang.gdata.Leaf('string', _netmask)
        if _route_tag is not None:
            children['route-tag'] = yang.gdata.Leaf('uint32', _route_tag)
        if _algorithm is not None:
            children['algorithm'] = yang.gdata.Leaf('uint32', _algorithm)
        return yang.gdata.ListElement([yang.gdata.yang_str(self.address)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(address=n.get_str("address"), netmask=n.get_str("netmask"), route_tag=n.get_opt_int("route-tag"), algorithm=n.get_opt_int("algorithm"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(address=yang.gdata.from_xml_str(n, "address"), netmask=yang.gdata.from_xml_str(n, "netmask"), route_tag=yang.gdata.from_xml_opt_int(n, "route-tag"), algorithm=yang.gdata.from_xml_opt_int(n, "algorithm"))

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg"
        self._name = 'secondary'
        self.elements = elements

    mut def create(self, address, netmask):
        for e in self.elements:
            match = True
            if e.address != address:
                match = False
                break
            if match:
                return e

        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry(address, netmask)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['address'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]:
        res = []
        for node in nodes:
            res.append(Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry.from_xml(node))
        return res


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['address']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'netmask':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'route-tag':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'algorithm':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['address']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['address'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['address'], [from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_address_full = jd.get('um-if-ip-address-cfg:address')
    child_address = child_address_full if child_address_full is not None else jd.get('address')
    if child_address is not None:
        children['address'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__address(child_address)
    child_netmask_full = jd.get('um-if-ip-address-cfg:netmask')
    child_netmask = child_netmask_full if child_netmask_full is not None else jd.get('netmask')
    if child_netmask is not None:
        children['netmask'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__netmask(child_netmask)
    child_route_tag_full = jd.get('um-if-ip-address-cfg:route-tag')
    child_route_tag = child_route_tag_full if child_route_tag_full is not None else jd.get('route-tag')
    if child_route_tag is not None:
        children['route-tag'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__route_tag(child_route_tag)
    child_algorithm_full = jd.get('um-if-ip-address-cfg:algorithm')
    child_algorithm = child_algorithm_full if child_algorithm_full is not None else jd.get('algorithm')
    if child_algorithm is not None:
        children['algorithm'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary__algorithm(child_algorithm)
    return yang.gdata.ListElement([str(child_address if child_address is not None else "")], children)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(e))
    return yang.gdata.List(keys=['address'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_address = n.children.get('address')
    if child_address is not None:
        if isinstance(child_address, yang.gdata.Leaf):
            children['address'] = child_address.val
    child_netmask = n.children.get('netmask')
    if child_netmask is not None:
        if isinstance(child_netmask, yang.gdata.Leaf):
            children['netmask'] = child_netmask.val
    child_route_tag = n.children.get('route-tag')
    if child_route_tag is not None:
        if isinstance(child_route_tag, yang.gdata.Leaf):
            children['route-tag'] = child_route_tag.val
    child_algorithm = n.children.get('algorithm')
    if child_algorithm is not None:
        if isinstance(child_algorithm, yang.gdata.Leaf):
            children['algorithm'] = child_algorithm.val
    return children

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_element(e))
    return elements


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(yang.adata.MNode):
    secondary: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary

    mut def __init__(self, secondary: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary_entry]=[]):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg"
        self.secondary = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(elements=secondary)
        self.secondary._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _secondary = self.secondary
        if _secondary is not None:
            children['secondary'] = _secondary.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(secondary=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary.from_gdata(n.get_opt_list("secondary")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(secondary=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary.from_xml(yang.gdata.get_xml_children(n, "secondary")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-if-ip-address-cfg:secondary' or point == 'secondary':
            child = {'secondary': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_secondary_full = jd.get('um-if-ip-address-cfg:secondary')
    child_secondary = child_secondary_full if child_secondary_full is not None else jd.get('secondary')
    if child_secondary is not None and isinstance(child_secondary, list):
        children['secondary'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(child_secondary)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_secondary = n.children.get('secondary')
    if child_secondary is not None:
        if isinstance(child_secondary, yang.gdata.List):
            children['secondary'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries__secondary(child_secondary)
    return children


mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__unnumbered(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(yang.adata.MNode):
    address: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address
    secondaries: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries
    unnumbered: ?str
    dhcp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp

    mut def __init__(self, address: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address=None, secondaries: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries=None, unnumbered: ?str, dhcp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg"
        self.address = address
        self_address = self.address
        if self_address is not None:
            self_address._parent = self
        if secondaries is not None:
            self.secondaries = secondaries
        else:
            self.secondaries = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries()
        self_secondaries = self.secondaries
        if self_secondaries is not None:
            self_secondaries._parent = self
        self.unnumbered = unnumbered
        self.dhcp = dhcp
        self_dhcp = self.dhcp
        if self_dhcp is not None:
            self_dhcp._parent = self

    mut def create_address(self, address, netmask):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(address, netmask)
        self.address = res
        return res

    mut def create_dhcp(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp()
        self.dhcp = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _address = self.address
        _secondaries = self.secondaries
        _unnumbered = self.unnumbered
        _dhcp = self.dhcp
        if _address is not None:
            children['address'] = _address.to_gdata()
        if _secondaries is not None:
            children['secondaries'] = _secondaries.to_gdata()
        if _unnumbered is not None:
            children['unnumbered'] = yang.gdata.Leaf('string', _unnumbered)
        if _dhcp is not None:
            children['dhcp'] = _dhcp.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(address=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.from_gdata(n.get_container("address")), secondaries=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries.from_gdata(n.get_opt_container("secondaries")), unnumbered=n.get_opt_str("unnumbered"), dhcp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.from_gdata(n.get_opt_container("dhcp")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(address=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address.from_xml(yang.gdata.get_xml_child(n, "address")), secondaries=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries.from_xml(yang.gdata.get_xml_opt_child(n, "secondaries")), unnumbered=yang.gdata.from_xml_opt_str(n, "unnumbered"), dhcp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp.from_xml(yang.gdata.get_xml_opt_child(n, "dhcp")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-if-ip-address-cfg:address' or point == 'address':
            child = {'address': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-if-ip-address-cfg:secondaries' or point == 'secondaries':
            child = {'secondaries': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-if-ip-address-cfg:unnumbered' or point == 'unnumbered':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'um-if-ip-address-cfg:dhcp' or point == 'dhcp':
            child = {'dhcp': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_address_full = jd.get('um-if-ip-address-cfg:address')
    child_address = child_address_full if child_address_full is not None else jd.get('address')
    if child_address is not None and isinstance(child_address, dict):
        children['address'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(child_address)
    child_secondaries_full = jd.get('um-if-ip-address-cfg:secondaries')
    child_secondaries = child_secondaries_full if child_secondaries_full is not None else jd.get('secondaries')
    if child_secondaries is not None and isinstance(child_secondaries, dict):
        children['secondaries'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(child_secondaries)
    child_unnumbered_full = jd.get('um-if-ip-address-cfg:unnumbered')
    child_unnumbered = child_unnumbered_full if child_unnumbered_full is not None else jd.get('unnumbered')
    if child_unnumbered is not None:
        children['unnumbered'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__unnumbered(child_unnumbered)
    child_dhcp_full = jd.get('um-if-ip-address-cfg:dhcp')
    child_dhcp = child_dhcp_full if child_dhcp_full is not None else jd.get('dhcp')
    if child_dhcp is not None and isinstance(child_dhcp, dict):
        children['dhcp'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(child_dhcp)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_address = n.children.get('address')
    if child_address is not None:
        if isinstance(child_address, yang.gdata.Container):
            children['address'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__address(child_address)
    child_secondaries = n.children.get('secondaries')
    if child_secondaries is not None:
        if isinstance(child_secondaries, yang.gdata.Container):
            children['secondaries'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__secondaries(child_secondaries)
    child_unnumbered = n.children.get('unnumbered')
    if child_unnumbered is not None:
        if isinstance(child_unnumbered, yang.gdata.Leaf):
            children['unnumbered'] = child_unnumbered.val
    child_dhcp = n.children.get('dhcp')
    if child_dhcp is not None:
        if isinstance(child_dhcp, yang.gdata.Container):
            children['dhcp'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses__dhcp(child_dhcp)
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(yang.adata.MNode):
    addresses: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses

    mut def __init__(self, addresses: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        if addresses is not None:
            self.addresses = addresses
        else:
            self.addresses = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses()
        self_addresses = self.addresses
        if self_addresses is not None:
            self_addresses._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _addresses = self.addresses
        if _addresses is not None:
            children['addresses'] = _addresses.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(addresses=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses.from_gdata(n.get_opt_container("addresses")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(addresses=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses.from_xml(yang.gdata.get_xml_opt_child(n, "addresses", "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-ip-address-cfg")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-if-ip-address-cfg:addresses' or point == 'addresses':
            child = {'addresses': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_addresses_full = jd.get('um-if-ip-address-cfg:addresses')
    child_addresses = child_addresses_full if child_addresses_full is not None else jd.get('addresses')
    if child_addresses is not None and isinstance(child_addresses, dict):
        children['addresses'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(child_addresses)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_addresses = n.children.get('addresses')
    if child_addresses is not None:
        if isinstance(child_addresses, yang.gdata.Container):
            children['um-if-ip-address-cfg:addresses'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4__addresses(child_addresses)
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(yang.adata.MNode):

    mut def __init__(self):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        pass

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF()
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF()
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(yang.adata.MNode):
    IETF: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF

    mut def __init__(self, IETF: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        self.IETF = IETF
        self_IETF = self.IETF
        if self_IETF is not None:
            self_IETF._parent = self

    mut def create_IETF(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF()
        self.IETF = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _IETF = self.IETF
        if _IETF is not None:
            children['IETF'] = _IETF.to_gdata()
        return yang.gdata.Container(children, presence=True)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(IETF=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF.from_gdata(n.get_opt_container("IETF")))
        return None

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(IETF=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF.from_xml(yang.gdata.get_xml_opt_child(n, "IETF")))
        return None


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-interface-cfg:IETF' or point == 'IETF':
            child = {'IETF': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_IETF_full = jd.get('um-interface-cfg:IETF')
    child_IETF = child_IETF_full if child_IETF_full is not None else jd.get('IETF')
    if child_IETF is not None and isinstance(child_IETF, dict):
        children['IETF'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(child_IETF)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_IETF = n.children.get('IETF')
    if child_IETF is not None:
        if isinstance(child_IETF, yang.gdata.Container):
            children['IETF'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay__IETF(child_IETF)
    return children


class Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(yang.adata.MNode):
    ppp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp
    hdlc: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc
    mfr: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr
    frame_relay: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay

    mut def __init__(self, ppp: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp=None, hdlc: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc=None, mfr: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr=None, frame_relay: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay=None):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        self.ppp = ppp
        self_ppp = self.ppp
        if self_ppp is not None:
            self_ppp._parent = self
        self.hdlc = hdlc
        self_hdlc = self.hdlc
        if self_hdlc is not None:
            self_hdlc._parent = self
        self.mfr = mfr
        self_mfr = self.mfr
        if self_mfr is not None:
            self_mfr._parent = self
        self.frame_relay = frame_relay
        self_frame_relay = self.frame_relay
        if self_frame_relay is not None:
            self_frame_relay._parent = self

    mut def create_ppp(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp()
        self.ppp = res
        return res

    mut def create_hdlc(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc()
        self.hdlc = res
        return res

    mut def create_mfr(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr()
        self.mfr = res
        return res

    mut def create_frame_relay(self):
        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay()
        self.frame_relay = res
        return res

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _ppp = self.ppp
        _hdlc = self.hdlc
        _mfr = self.mfr
        _frame_relay = self.frame_relay
        if _ppp is not None:
            children['ppp'] = _ppp.to_gdata()
        if _hdlc is not None:
            children['hdlc'] = _hdlc.to_gdata()
        if _mfr is not None:
            children['mfr'] = _mfr.to_gdata()
        if _frame_relay is not None:
            children['frame-relay'] = _frame_relay.to_gdata()
        return yang.gdata.Container(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(ppp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp.from_gdata(n.get_opt_container("ppp")), hdlc=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc.from_gdata(n.get_opt_container("hdlc")), mfr=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr.from_gdata(n.get_opt_container("mfr")), frame_relay=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay.from_gdata(n.get_opt_container("frame-relay")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(ppp=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp.from_xml(yang.gdata.get_xml_opt_child(n, "ppp")), hdlc=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc.from_xml(yang.gdata.get_xml_opt_child(n, "hdlc")), mfr=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr.from_xml(yang.gdata.get_xml_opt_child(n, "mfr")), frame_relay=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay.from_xml(yang.gdata.get_xml_opt_child(n, "frame-relay")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation()


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-interface-cfg:ppp' or point == 'ppp':
            child = {'ppp': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-interface-cfg:hdlc' or point == 'hdlc':
            child = {'hdlc': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-interface-cfg:mfr' or point == 'mfr':
            child = {'mfr': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(jd, rest_path, op) }
            return yang.gdata.Container(child)
        if point == 'um-interface-cfg:frame-relay' or point == 'frame-relay':
            child = {'frame-relay': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_ppp_full = jd.get('um-interface-cfg:ppp')
    child_ppp = child_ppp_full if child_ppp_full is not None else jd.get('ppp')
    if child_ppp is not None and isinstance(child_ppp, dict):
        children['ppp'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(child_ppp)
    child_hdlc_full = jd.get('um-interface-cfg:hdlc')
    child_hdlc = child_hdlc_full if child_hdlc_full is not None else jd.get('hdlc')
    if child_hdlc is not None and isinstance(child_hdlc, dict):
        children['hdlc'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(child_hdlc)
    child_mfr_full = jd.get('um-interface-cfg:mfr')
    child_mfr = child_mfr_full if child_mfr_full is not None else jd.get('mfr')
    if child_mfr is not None and isinstance(child_mfr, dict):
        children['mfr'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(child_mfr)
    child_frame_relay_full = jd.get('um-interface-cfg:frame-relay')
    child_frame_relay = child_frame_relay_full if child_frame_relay_full is not None else jd.get('frame-relay')
    if child_frame_relay is not None and isinstance(child_frame_relay, dict):
        children['frame-relay'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(child_frame_relay)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_ppp = n.children.get('ppp')
    if child_ppp is not None:
        if isinstance(child_ppp, yang.gdata.Container):
            children['ppp'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__ppp(child_ppp)
    child_hdlc = n.children.get('hdlc')
    if child_hdlc is not None:
        if isinstance(child_hdlc, yang.gdata.Container):
            children['hdlc'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__hdlc(child_hdlc)
    child_mfr = n.children.get('mfr')
    if child_mfr is not None:
        if isinstance(child_mfr, yang.gdata.Container):
            children['mfr'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__mfr(child_mfr)
    child_frame_relay = n.children.get('frame-relay')
    if child_frame_relay is not None:
        if isinstance(child_frame_relay, yang.gdata.Container):
            children['frame-relay'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation__frame_relay(child_frame_relay)
    return children


mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__shutdown(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("empty", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__mtu(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("uint32", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__description(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__vrf(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(yang.adata.MNode):
    interface_name: str
    sub_interface_type: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type
    ipv4: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4
    ipv6: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6
    encapsulation: Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation
    shutdown: ?bool
    mtu: ?int
    description: ?str
    vrf: ?str

    mut def __init__(self, interface_name: str, sub_interface_type: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type=None, ipv4: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4=None, ipv6: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6=None, encapsulation: ?Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation=None, shutdown: ?bool, mtu: ?int, description: ?str, vrf: ?str):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        self.interface_name = interface_name
        if sub_interface_type is not None:
            self.sub_interface_type = sub_interface_type
        else:
            self.sub_interface_type = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type()
        self_sub_interface_type = self.sub_interface_type
        if self_sub_interface_type is not None:
            self_sub_interface_type._parent = self
        if ipv4 is not None:
            self.ipv4 = ipv4
        else:
            self.ipv4 = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4()
        self_ipv4 = self.ipv4
        if self_ipv4 is not None:
            self_ipv4._parent = self
        if ipv6 is not None:
            self.ipv6 = ipv6
        else:
            self.ipv6 = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6()
        self_ipv6 = self.ipv6
        if self_ipv6 is not None:
            self_ipv6._parent = self
        if encapsulation is not None:
            self.encapsulation = encapsulation
        else:
            self.encapsulation = Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation()
        self_encapsulation = self.encapsulation
        if self_encapsulation is not None:
            self_encapsulation._parent = self
        self.shutdown = shutdown
        self.mtu = mtu
        self.description = description
        self.vrf = vrf

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface_name = self.interface_name
        _sub_interface_type = self.sub_interface_type
        _ipv4 = self.ipv4
        _ipv6 = self.ipv6
        _encapsulation = self.encapsulation
        _shutdown = self.shutdown
        _mtu = self.mtu
        _description = self.description
        _vrf = self.vrf
        if _interface_name is not None:
            children['interface-name'] = yang.gdata.Leaf('string', _interface_name)
        if _sub_interface_type is not None:
            children['sub-interface-type'] = _sub_interface_type.to_gdata()
        if _ipv4 is not None:
            children['ipv4'] = _ipv4.to_gdata()
        if _ipv6 is not None:
            children['ipv6'] = _ipv6.to_gdata()
        if _encapsulation is not None:
            children['encapsulation'] = _encapsulation.to_gdata()
        if _shutdown is not None:
            children['shutdown'] = yang.gdata.Leaf('empty', _shutdown)
        if _mtu is not None:
            children['mtu'] = yang.gdata.Leaf('uint32', _mtu)
        if _description is not None:
            children['description'] = yang.gdata.Leaf('string', _description)
        if _vrf is not None:
            children['vrf'] = yang.gdata.Leaf('string', _vrf, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg')
        return yang.gdata.ListElement([yang.gdata.yang_str(self.interface_name)], children)

    @staticmethod
    mut def from_gdata(n: yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(interface_name=n.get_str("interface-name"), sub_interface_type=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type.from_gdata(n.get_opt_container("sub-interface-type")), ipv4=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4.from_gdata(n.get_opt_container("ipv4")), ipv6=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6.from_gdata(n.get_opt_container("ipv6")), encapsulation=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation.from_gdata(n.get_opt_container("encapsulation")), shutdown=n.get_opt_bool("shutdown"), mtu=n.get_opt_int("mtu"), description=n.get_opt_str("description"), vrf=n.get_opt_str("vrf"))

    @staticmethod
    mut def from_xml(n: xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry:
        return Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(interface_name=yang.gdata.from_xml_str(n, "interface-name"), sub_interface_type=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type.from_xml(yang.gdata.get_xml_opt_child(n, "sub-interface-type")), ipv4=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4.from_xml(yang.gdata.get_xml_opt_child(n, "ipv4")), ipv6=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6.from_xml(yang.gdata.get_xml_opt_child(n, "ipv6")), encapsulation=Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation.from_xml(yang.gdata.get_xml_opt_child(n, "encapsulation")), shutdown=yang.gdata.from_xml_opt_bool(n, "shutdown"), mtu=yang.gdata.from_xml_opt_int(n, "mtu"), description=yang.gdata.from_xml_opt_str(n, "description"), vrf=yang.gdata.from_xml_opt_str(n, "vrf", "http://cisco.com/ns/yang/Cisco-IOS-XR-um-if-vrf-cfg"))

class Cisco_IOS_XR_um_interface_cfg__interfaces__interface(yang.adata.MNode):
    elements: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]
    mut def __init__(self, elements=[]):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        self._name = 'interface'
        self.elements = elements

    mut def create(self, interface_name):
        for e in self.elements:
            match = True
            if e.interface_name != interface_name:
                match = False
                break
            if match:
                return e

        res = Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry(interface_name)
        self.elements.append(res)
        return res

    mut def to_gdata(self):
        elements = []
        for e in self.elements:
            e_gdata = e.to_gdata()
            if isinstance(e_gdata, yang.gdata.ListElement):
                elements.append(e_gdata)
        return yang.gdata.List(['interface-name'], elements)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.List) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]:
        res = []
        if n is not None:
            for e in n.elements:
                res.append(Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry.from_gdata(e))
        return res

    @staticmethod
    mut def from_xml(nodes: list[xml.Node]) -> list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]:
        res = []
        for node in nodes:
            res.append(Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry.from_xml(node))
        return res


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.ListElement:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        val = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(jd_dict)
        if op == "merge":
            return val
        elif op == "remove":
            return yang.gdata.AbsentListElement(val.key_vals)
        raise ValueError("Invalid operation")
    elif len(path) > 1:
        keys = path[0].split(",")
        point = path[1]
        rest_path = path[2:]
        children: dict[str, yang.gdata.Node] = {}
        for idx, key in enumerate(['interface-name']):
            children[key] = yang.gdata.Leaf("str", keys[idx])
        if point == 'sub-interface-type':
            children['sub-interface-type'] = from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(jd, rest_path, op)
        if point == 'ipv4':
            children['ipv4'] = from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(jd, rest_path, op)
        if point == 'ipv6':
            children['ipv6'] = from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(jd, rest_path, op)
        if point == 'encapsulation':
            children['encapsulation'] = from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(jd, rest_path, op)
        if point == 'shutdown':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'mtu':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'description':
            raise ValueError("Invalid json path to non-inner node")
        if point == 'vrf':
            raise ValueError("Invalid json path to non-inner node")
        return yang.gdata.ListElement(keys, children)
    raise ValueError("unreachable - no keys to list element")

mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.List:
    if len(path) == 1:
        point = path[0]
        keys = point.split(",")
        jd_dict = yang.gdata.unwrap_dict(jd)
        # Check that all keys are present in payload.
        # If present, they must equal the keys in the path
        # If not present, fill in from path
        for key in ['interface-name']:
            if key not in jd_dict:
                jd_dict[key] = keys.pop(0)
            else:
                if str(jd_dict[key]) != keys.pop(0):
                    raise ValueError("Key value mismatch between path and payload")
        element = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(jd_dict)
        elements = []
        if op == "merge":
            elements.append(element)
        elif op == "remove":
            elements.append(yang.gdata.AbsentListElement(element.key_vals))
        return yang.gdata.List(['interface-name'], elements)
    elif len(path) > 1:
        return yang.gdata.List(['interface-name'], [from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(jd, path, op)])
    raise ValueError("Unable to resolve path, no keys provided")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(jd: dict[str, ?value]) -> yang.gdata.ListElement:
    children = {}
    child_interface_name_full = jd.get('um-interface-cfg:interface-name')
    child_interface_name = child_interface_name_full if child_interface_name_full is not None else jd.get('interface-name')
    if child_interface_name is not None:
        children['interface-name'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__interface_name(child_interface_name)
    child_sub_interface_type_full = jd.get('um-interface-cfg:sub-interface-type')
    child_sub_interface_type = child_sub_interface_type_full if child_sub_interface_type_full is not None else jd.get('sub-interface-type')
    if child_sub_interface_type is not None and isinstance(child_sub_interface_type, dict):
        children['sub-interface-type'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(child_sub_interface_type)
    child_ipv4_full = jd.get('um-interface-cfg:ipv4')
    child_ipv4 = child_ipv4_full if child_ipv4_full is not None else jd.get('ipv4')
    if child_ipv4 is not None and isinstance(child_ipv4, dict):
        children['ipv4'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(child_ipv4)
    child_ipv6_full = jd.get('um-interface-cfg:ipv6')
    child_ipv6 = child_ipv6_full if child_ipv6_full is not None else jd.get('ipv6')
    if child_ipv6 is not None and isinstance(child_ipv6, dict):
        children['ipv6'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(child_ipv6)
    child_encapsulation_full = jd.get('um-interface-cfg:encapsulation')
    child_encapsulation = child_encapsulation_full if child_encapsulation_full is not None else jd.get('encapsulation')
    if child_encapsulation is not None and isinstance(child_encapsulation, dict):
        children['encapsulation'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(child_encapsulation)
    child_shutdown_full = jd.get('um-interface-cfg:shutdown')
    child_shutdown = child_shutdown_full if child_shutdown_full is not None else jd.get('shutdown')
    if child_shutdown is not None:
        children['shutdown'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__shutdown(child_shutdown)
    child_mtu_full = jd.get('um-interface-cfg:mtu')
    child_mtu = child_mtu_full if child_mtu_full is not None else jd.get('mtu')
    if child_mtu is not None:
        children['mtu'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__mtu(child_mtu)
    child_description_full = jd.get('um-interface-cfg:description')
    child_description = child_description_full if child_description_full is not None else jd.get('description')
    if child_description is not None:
        children['description'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__description(child_description)
    child_vrf_full = jd.get('um-if-vrf-cfg:vrf')
    child_vrf = child_vrf_full if child_vrf_full is not None else jd.get('vrf')
    if child_vrf is not None:
        children['vrf'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__vrf(child_vrf)
    return yang.gdata.ListElement([str(child_interface_name if child_interface_name is not None else "")], children)

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface(jd: list[dict[str, ?value]]) -> yang.gdata.List:
    elements = []
    for e in jd:
        if isinstance(e, dict):
            elements.append(from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(e))
    return yang.gdata.List(keys=['interface-name'], elements=elements, user_order=False, ns=None, prefix=None)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(n: yang.gdata.ListElement) -> dict[str, ?value]:
    children = {}
    child_interface_name = n.children.get('interface-name')
    if child_interface_name is not None:
        if isinstance(child_interface_name, yang.gdata.Leaf):
            children['interface-name'] = child_interface_name.val
    child_sub_interface_type = n.children.get('sub-interface-type')
    if child_sub_interface_type is not None:
        if isinstance(child_sub_interface_type, yang.gdata.Container):
            children['sub-interface-type'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__sub_interface_type(child_sub_interface_type)
    child_ipv4 = n.children.get('ipv4')
    if child_ipv4 is not None:
        if isinstance(child_ipv4, yang.gdata.Container):
            children['ipv4'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv4(child_ipv4)
    child_ipv6 = n.children.get('ipv6')
    if child_ipv6 is not None:
        if isinstance(child_ipv6, yang.gdata.Container):
            children['ipv6'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__ipv6(child_ipv6)
    child_encapsulation = n.children.get('encapsulation')
    if child_encapsulation is not None:
        if isinstance(child_encapsulation, yang.gdata.Container):
            children['encapsulation'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface__encapsulation(child_encapsulation)
    child_shutdown = n.children.get('shutdown')
    if child_shutdown is not None:
        if isinstance(child_shutdown, yang.gdata.Leaf):
            children['shutdown'] = child_shutdown.val
    child_mtu = n.children.get('mtu')
    if child_mtu is not None:
        if isinstance(child_mtu, yang.gdata.Leaf):
            children['mtu'] = child_mtu.val
    child_description = n.children.get('description')
    if child_description is not None:
        if isinstance(child_description, yang.gdata.Leaf):
            children['description'] = child_description.val
    child_vrf = n.children.get('vrf')
    if child_vrf is not None:
        if isinstance(child_vrf, yang.gdata.Leaf):
            children['um-if-vrf-cfg:vrf'] = child_vrf.val
    return children

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface(n: yang.gdata.List) -> list[dict[str, ?value]]:
    elements = []
    for e in n.elements:
        elements.append(to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface_element(e))
    return elements


class Cisco_IOS_XR_um_interface_cfg__interfaces(yang.adata.MNode):
    interface: Cisco_IOS_XR_um_interface_cfg__interfaces__interface

    mut def __init__(self, interface: list[Cisco_IOS_XR_um_interface_cfg__interfaces__interface_entry]=[]):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg"
        self.interface = Cisco_IOS_XR_um_interface_cfg__interfaces__interface(elements=interface)
        self.interface._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _interface = self.interface
        if _interface is not None:
            children['interface'] = _interface.to_gdata()
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces(interface=Cisco_IOS_XR_um_interface_cfg__interfaces__interface.from_gdata(n.get_opt_list("interface")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_interface_cfg__interfaces:
        if n != None:
            return Cisco_IOS_XR_um_interface_cfg__interfaces(interface=Cisco_IOS_XR_um_interface_cfg__interfaces__interface.from_xml(yang.gdata.get_xml_children(n, "interface")))
        return Cisco_IOS_XR_um_interface_cfg__interfaces()


mut def from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-interface-cfg:interface' or point == 'interface':
            child = {'interface': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces__interface(jd, rest_path, op) }
            return yang.gdata.Container(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_interface_cfg__interfaces(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_interface_cfg__interfaces(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_interface_full = jd.get('um-interface-cfg:interface')
    child_interface = child_interface_full if child_interface_full is not None else jd.get('interface')
    if child_interface is not None and isinstance(child_interface, list):
        children['interface'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface(child_interface)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_interface_cfg__interfaces(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_interface = n.children.get('interface')
    if child_interface is not None:
        if isinstance(child_interface, yang.gdata.List):
            children['interface'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces__interface(child_interface)
    return children


mut def from_json_Cisco_IOS_XR_um_hostname_cfg__hostname__system_network_name(val: value) -> yang.gdata.Leaf:
    return yang.gdata.Leaf("string", val)

class Cisco_IOS_XR_um_hostname_cfg__hostname(yang.adata.MNode):
    system_network_name: ?str

    mut def __init__(self, system_network_name: ?str):
        self._ns = "http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg"
        self.system_network_name = system_network_name

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _system_network_name = self.system_network_name
        if _system_network_name is not None:
            children['system-network-name'] = yang.gdata.Leaf('string', _system_network_name)
        return yang.gdata.Container(children, ns='http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg')

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> Cisco_IOS_XR_um_hostname_cfg__hostname:
        if n != None:
            return Cisco_IOS_XR_um_hostname_cfg__hostname(system_network_name=n.get_opt_str("system-network-name"))
        return Cisco_IOS_XR_um_hostname_cfg__hostname()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> Cisco_IOS_XR_um_hostname_cfg__hostname:
        if n != None:
            return Cisco_IOS_XR_um_hostname_cfg__hostname(system_network_name=yang.gdata.from_xml_opt_str(n, "system-network-name"))
        return Cisco_IOS_XR_um_hostname_cfg__hostname()


mut def from_json_path_Cisco_IOS_XR_um_hostname_cfg__hostname(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-hostname-cfg:system-network-name' or point == 'system-network-name':
            raise ValueError("Invalid json path to non-inner node")
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json_Cisco_IOS_XR_um_hostname_cfg__hostname(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json_Cisco_IOS_XR_um_hostname_cfg__hostname(jd: dict[str, ?value]) -> yang.gdata.Container:
    children = {}
    child_system_network_name_full = jd.get('um-hostname-cfg:system-network-name')
    child_system_network_name = child_system_network_name_full if child_system_network_name_full is not None else jd.get('system-network-name')
    if child_system_network_name is not None:
        children['system-network-name'] = from_json_Cisco_IOS_XR_um_hostname_cfg__hostname__system_network_name(child_system_network_name)
    return yang.gdata.Container(children)

mut def to_json_Cisco_IOS_XR_um_hostname_cfg__hostname(n: yang.gdata.Container) -> dict[str, ?value]:
    children = {}
    child_system_network_name = n.children.get('system-network-name')
    if child_system_network_name is not None:
        if isinstance(child_system_network_name, yang.gdata.Leaf):
            children['system-network-name'] = child_system_network_name.val
    return children


class root(yang.adata.MNode):
    vrfs: Cisco_IOS_XR_um_vrf_cfg__vrfs
    interfaces: Cisco_IOS_XR_um_interface_cfg__interfaces
    hostname: Cisco_IOS_XR_um_hostname_cfg__hostname

    mut def __init__(self, vrfs: ?Cisco_IOS_XR_um_vrf_cfg__vrfs=None, interfaces: ?Cisco_IOS_XR_um_interface_cfg__interfaces=None, hostname: ?Cisco_IOS_XR_um_hostname_cfg__hostname=None):
        self._ns = ""
        if vrfs is not None:
            self.vrfs = vrfs
        else:
            self.vrfs = Cisco_IOS_XR_um_vrf_cfg__vrfs()
        self_vrfs = self.vrfs
        if self_vrfs is not None:
            self_vrfs._parent = self
        if interfaces is not None:
            self.interfaces = interfaces
        else:
            self.interfaces = Cisco_IOS_XR_um_interface_cfg__interfaces()
        self_interfaces = self.interfaces
        if self_interfaces is not None:
            self_interfaces._parent = self
        if hostname is not None:
            self.hostname = hostname
        else:
            self.hostname = Cisco_IOS_XR_um_hostname_cfg__hostname()
        self_hostname = self.hostname
        if self_hostname is not None:
            self_hostname._parent = self

    mut def to_gdata(self) -> yang.gdata.Node:
        children = {}
        _vrfs = self.vrfs
        _interfaces = self.interfaces
        _hostname = self.hostname
        if _vrfs is not None:
            children['vrfs'] = _vrfs.to_gdata()
        if _interfaces is not None:
            children['interfaces'] = _interfaces.to_gdata()
        if _hostname is not None:
            children['hostname'] = _hostname.to_gdata()
        return yang.gdata.Root(children)

    @staticmethod
    mut def from_gdata(n: ?yang.gdata.Node) -> root:
        if n != None:
            return root(vrfs=Cisco_IOS_XR_um_vrf_cfg__vrfs.from_gdata(n.get_opt_container("vrfs")), interfaces=Cisco_IOS_XR_um_interface_cfg__interfaces.from_gdata(n.get_opt_container("interfaces")), hostname=Cisco_IOS_XR_um_hostname_cfg__hostname.from_gdata(n.get_opt_container("hostname")))
        return root()

    @staticmethod
    mut def from_xml(n: ?xml.Node) -> root:
        if n != None:
            return root(vrfs=Cisco_IOS_XR_um_vrf_cfg__vrfs.from_xml(yang.gdata.get_xml_opt_child(n, "vrfs", "http://cisco.com/ns/yang/Cisco-IOS-XR-um-vrf-cfg")), interfaces=Cisco_IOS_XR_um_interface_cfg__interfaces.from_xml(yang.gdata.get_xml_opt_child(n, "interfaces", "http://cisco.com/ns/yang/Cisco-IOS-XR-um-interface-cfg")), hostname=Cisco_IOS_XR_um_hostname_cfg__hostname.from_xml(yang.gdata.get_xml_opt_child(n, "hostname", "http://cisco.com/ns/yang/Cisco-IOS-XR-um-hostname-cfg")))
        return root()


mut def from_json_path(jd: value, path: list[str]=[], op: ?str="merge") -> yang.gdata.Node:
    # path handling
    if len(path) > 0:
        point = path[0]
        rest_path = path[1:]
        if point == 'um-vrf-cfg:vrfs':
            child = {'vrfs': from_json_path_Cisco_IOS_XR_um_vrf_cfg__vrfs(jd, rest_path, op) }
            return yang.gdata.Root(child)
        if point == 'um-interface-cfg:interfaces':
            child = {'interfaces': from_json_path_Cisco_IOS_XR_um_interface_cfg__interfaces(jd, rest_path, op) }
            return yang.gdata.Root(child)
        if point == 'um-hostname-cfg:hostname':
            child = {'hostname': from_json_path_Cisco_IOS_XR_um_hostname_cfg__hostname(jd, rest_path, op) }
            return yang.gdata.Root(child)
        raise ValueError("Invalid path")
    elif len(path) == 0:
        if op == "merge":
            return from_json(yang.gdata.unwrap_dict(jd))
        elif op == "remove":
            return yang.gdata.Absent()
        raise ValueError("Invalid operation")
    raise ValueError("Unable to resolve path")

mut def from_json(jd: dict[str, ?value]) -> yang.gdata.Root:
    children = {}
    child_vrfs = jd.get('um-vrf-cfg:vrfs')
    if child_vrfs is not None and isinstance(child_vrfs, dict):
        children['vrfs'] = from_json_Cisco_IOS_XR_um_vrf_cfg__vrfs(child_vrfs)
    child_interfaces = jd.get('um-interface-cfg:interfaces')
    if child_interfaces is not None and isinstance(child_interfaces, dict):
        children['interfaces'] = from_json_Cisco_IOS_XR_um_interface_cfg__interfaces(child_interfaces)
    child_hostname = jd.get('um-hostname-cfg:hostname')
    if child_hostname is not None and isinstance(child_hostname, dict):
        children['hostname'] = from_json_Cisco_IOS_XR_um_hostname_cfg__hostname(child_hostname)
    return yang.gdata.Root(children)

mut def to_json(n: yang.gdata.Root) -> dict[str, ?value]:
    children = {}
    child_vrfs = n.children.get('vrfs')
    if child_vrfs is not None:
        if isinstance(child_vrfs, yang.gdata.Container):
            children['um-vrf-cfg:vrfs'] = to_json_Cisco_IOS_XR_um_vrf_cfg__vrfs(child_vrfs)
    child_interfaces = n.children.get('interfaces')
    if child_interfaces is not None:
        if isinstance(child_interfaces, yang.gdata.Container):
            children['um-interface-cfg:interfaces'] = to_json_Cisco_IOS_XR_um_interface_cfg__interfaces(child_interfaces)
    child_hostname = n.children.get('hostname')
    if child_hostname is not None:
        if isinstance(child_hostname, yang.gdata.Container):
            children['um-hostname-cfg:hostname'] = to_json_Cisco_IOS_XR_um_hostname_cfg__hostname(child_hostname)
    return children

